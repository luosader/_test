如何使用fsockopen函数实现异步执行PHP
http://zhidao.baidu.com/link?url=zrHvK_nTI_anwO_bH-KejRzm661BCEICz5EouF2h_Zeq59UcK48_jRGut2jDL20_pn4HGYa-Mjp7WyxzlwH2AnrCYrcVNlFHEaxLSXwSTa_



Web服务器执行一个PHP脚本，有时耗时很长才能返回执行结果，后面的脚本需要等待很长一段时间才能继续执行。如果想实现只简单触发耗时脚本的执行而不等待执行结果就直接执行下一步操作，可以通过fscokopen函数来实现。
　　PHP支持socket编程，fscokopen函数返回一个到远程主机连接的句柄，可以像使用fopen返回的句柄一样，对它进行fwrite、fgets、fread等操作。使用fsockopen连接到本地服务器，触发脚本执行，然后立即返回，不等待脚本执行完成，即可实现异步执行PHP的效果。
　　示例代码如下：
　　functiontriggerRequest($url,$post_data=array(),$cookie=array()){
　　　　$method="GET";//通过POST或者GET传递一些参数给要触发的脚本
　　　　$url_array=parse_url($url);//获取URL信息
　　　　$port=isset($url_array['port'])?$url_array['port']:80;
　　　　$fp=fsockopen($url_array['host'],$port,$errno,$errstr,30);
　　　　if(!$fp){
　　　　　　returnFALSE;
　　　　}
　　　　$getPath=$url_array['path']."?".$url_array['query'];
　　　　if(!empty($post_data)){
　　　　　　$method="POST";
　　　　}
　　　　$header=$method."".$getPath;
　　　　$header.="HTTP/1.1\r\n";
　　　　$header.="Host:".$url_array['host']."\r\n";//HTTP1.1Host域不能省略
　　/*以下头信息域可以省略
　　　　$header.="User-Agent:Mozilla/5.0(Windows;U;
WindowsNT5.1;en-US;rv:1.8.1.13)Gecko/20080311Firefox/2.0.0.13\r\n";
　　$header.="Accept:text/xml,application/xml,application/
xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,q=0.5\r\n";
　　$header.="Accept-Language:en-us,en;q=0.5";
　　$header.="Accept-Encoding:gzip,deflate\r\n";
　　*/
　　$header.="Connection:Close\r\n";
　　if(!empty($cookie)){
　　　　$_cookie=strval(NULL);
　　　　foreach($cookieas$k=>$v){
　　　　　　$_cookie.=$k."=".$v.";";
　　　　}
　　　　$cookie_str="Cookie:".base64_encode($_cookie)."\r\n";//传递Cookie
　　　　$header.=$cookie_str;
　　}
　　if(!empty($post_data)){
　　　　$_post=strval(NULL);
　　　　foreach($post_dataas$k=>$v){
　　　　　　$_post.=$k."=".$v."&";
　　　　}
　　　　$post_str="Content-Type:application/x-www-form-urlencoded\r\n";
　　　　$post_str.="Content-Length:".strlen($_post)."\r\n";//POST数据的长度
　　　　$post_str.=$_post."\r\n\r\n";//传递POST数据
　　　　$header.=$post_str;
　　}
　　fwrite($fp,$header);
　　//echofread($fp,1024);//服务器返回
　　fclose($fp);
　　returntrue;
　　}
　　这样就可以通过fsockopen()函数来触发一个PHP脚本的执行，然后函数就会返回。接着执行下一步操作了。
　　现在存在一个问题：当客户端断开连接后，也就是triggerRequest发送请求后，立即关闭了连接，那么可能会引起服务器端正在执行的脚本退出。
　　在PHP内部，系统维护着连接状态，其状态有三种可能的情况：
　　*0–NORMAL（正常）
　　*1–ABORTED（异常退出）
　　*2–TIMEOUT（超时）
　　当PHP脚本正常地运行NORMAL状态时，连接为有效。当客户端中断连接时，ABORTED状态的标记将会被打开。远程客户端连接的中断通常是由用户点击STOP按钮导致的。当连接时间超过PHP的时限（参阅set_time_limit()函数）时，TIMEOUT状态的标记将被打开。
　　可以决定脚本是否需要在客户端中断连接时退出。有时候让脚本完整地运行会带来很多方便，即使没有远程浏览器接受脚本的输出。默认的情况是当远程客户端连接中断时脚本将会退出。该处理过程可由php.ini的ignore_user_abort或由Apache.conf设置中对应的"php_valueignore_user_abort"以及ignore_user_abort()函数来控制。如果没有告诉PHP忽略用户的中断，脚本将会被中断，除非通过register_shutdown_function()设置了关闭触发函数。通过该关闭触发函数，当远程用户点击STOP按钮后，脚本再次尝试输出数据时，PHP将会检测到连接已被中断，并调用关闭触发函数。
　　脚本也有可能被内置的脚本计时器中断。默认的超时限制为30秒。这个值可以通过设置php.ini的max_execution_time或Apache.conf设置中对应的"php_valuemax_execution_time"参数或者set_time_limit()函数来更改。当计数器超时的时候，脚本将会类似于以上连接中断的情况退出，先前被注册过的关闭触发函数也将在这时被执行。在该关闭触发函数中，可以通过调用connection_status()函数来检查超时是否导致关闭触发函数被调用。如果超时导致了关闭触发函数的调用，该函数将返回2。
　　需要注意的一点是ABORTED和TIMEOUT状态可以同时有效。这在告诉PHP忽略用户的退出操作时是可能的。PHP将仍然注意用户已经中断了连接但脚本仍然在运行的情况。如果到了运行的时间限制，脚本将被退出，设置过的关闭触发函数也将被执行。在这时会发现函数connection_status()返回3。
　　所以还在要触发的脚本中指明:
　　ignore_user_abort(TRUE);//如果客户端断开连接，不会引起脚本abort
　　set_time_limit(0);//取消脚本执行延时上限
　　或使用:
　　register_shutdown_function(callbackfuction[,parameters]);//注册脚本退出时执行的函数